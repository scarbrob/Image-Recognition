"""
This program makes a neural network that distinguishes between Cats and Dogs.

@author Ben Scarbrough
@version 12/3/19
"""

import os
import sys
import numpy as np
import cv2
import random
import pickle
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten, Conv2D, MaxPooling2D


# image_directory = None
# nn_name = None
image_size = 100 # Pixels
categories = ['Cats', 'Dogs']
training_array = []



def main():
    """
    This is the main function. To run by giving it the path to an image directory and the name of the neural network that will be generated.
    The image directory must be entered inside quotes.
    """
    # If the program is given more than one argument (2 because python takes the program as the first argument) exit.
    if len(sys.argv) > 3 or len(sys.argv) < 3:
        print("This program takes two arguments, an image directory, and the name for the neural network file generated by this program.")
        sys.exit(0)
    else:
        global image_directory, nn_name # Make global variables for path and neural network name
        image_directory = sys.argv[1]
        if not os.path.isdir(image_directory):
            print(str("The image directory " + image_directory + " does not exist."))
            sys.exit(0)
        nn_name = sys.argv[2]

    _run()


def _run():
    """
    A function to run the program.
    """
    _make_cd_directories()
    _training_data()
    _make_arrays()
    _make_model()


def _make_cd_directories():
    """
    A function to make cat and dog directories if they do not exist. Then transfer all images with a "c" in the title to the Cats folder, and "d" to the Dogs folder.
    """
    cat_dir = os.path.join(image_directory, "Cats")#str(image_directory + "Cats")
    dog_dir = os.path.join(image_directory, "Dogs")#str(image_directory + "Dogs")

    # If the path to the Cats directory doesn't exist, make one and move all the "c" files into it.
    if not os.path.isdir(cat_dir):
        os.mkdir(cat_dir)
        print(str("Directory " + cat_dir + " created."))
        for img in os.listdir(image_directory):
            temp_img = "/" + str(img)
            if "c" in str(img):
                os.rename(str(image_directory + temp_img), str(cat_dir + temp_img)) # Move the images

    # If the path to the Dogs directory doesn't exist, make one and move all the "d" files into it.
    if not os.path.isdir(dog_dir):
        os.mkdir(dog_dir)
        print(str("Directory " + dog_dir + " created."))
        for img in os.listdir(image_directory):
            temp_img = "/" + str(img)
            if "d" in str(img):
                os.rename(str(image_directory + temp_img), str(dog_dir + temp_img)) # Move the images


def _training_data():
    """
    Convert all the images into an array so we can train on it.
    """
    for c in categories: # For Cats & Dogs...
        path = os.path.join(image_directory, c) # Make the path
        classification = categories.index(c)

        for img in os.listdir(path): # For every image in the directory (Cats/Dogs) read it and convert it to grayscale.
            try:
                array = cv2.imread(os.path.join(path, img), cv2.IMREAD_GRAYSCALE) # convert the images to an array
                temp = cv2.resize(array, (image_size, image_size)) # Resize the array to the size of the image.
                training_array.append([temp, classification]) # add the array of the image and it's classification to the training array
            except Exception as e:
                print(e)

    random.shuffle(training_array) # Shuffle the training array after it is full


def _make_arrays():
    """
    A function to create numpy arrays of the training_array. These are used in making the model.
    """
    feat = [] # Make an array for the features (i.e. the pixels arrays of the image)
    categ = [] # Make an array for the category (0 for cats, 1 for dogs)

    for x,y in training_array: # x is feature, y is category
        feat.append(x)
        categ.append(y)

    global featnp, categnp
    featnp = np.array(feat).reshape(-1, image_size, image_size, 1) # make the numpy array of features and make sure it is resized to the size of the image
    categnp = np.array(categ) # If this isn't a numpy array model.fit won't work.


def _make_model():
    """
    A function to generate the neural network.
    """

    dense = 0 # The density of the network
    layers = 64 # The number of layers
    conv = 3 # the Convolution


    model = Sequential()

    model.add(Conv2D(layers, (3, 3), input_shape=featnp.shape[1:]))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))

    for i in range(conv -1):
        model.add(Conv2D(layers, (3, 3)))
        model.add(Activation('relu'))
        model.add(MaxPooling2D(pool_size=(2, 2)))

    model.add(Flatten())

    for j in range(dense):
        model.add(Dense(l))
        model.add(Activation('relu'))

    model.add(Dense(1))
    model.add(Activation('sigmoid'))

    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

    model.fit(featnp, categnp, batch_size=64, epochs=16, validation_split=0.3)

    model.save(nn_name, include_optimizer = False)


# Put at the bottom, runs the program from main.
if __name__ == "__main__":
    main()
